Exploring Lit: A Lightweight Alternative in Web Development

This is the first in a series of articles where I'll delve into Lit, and compare it to the widely used React. My goal is to shed light on Lit's strengths and demonstrate its viability as a solid alternative for developers.

Why I Chose Lit, and What Exactly Is It?

I recently found myself working on a project where optimization, lightweightness, and framework integration were paramount. Although the project isn't massive, it demanded reusable components that could be shared across different NPM packages. For this, I needed four key capabilities that Lit delivered perfectly:

1. Code Isolation: Ensuring styles and markup don't bleed into or out of components.

2. HTML Templating: Moving away from direct DOM manipulation for cleaner code.

3. Lifecycle Methods: For managing component behavior over time.

4. Simple Integration: Seamlessly fitting into an existing system that treats my package as a sub-page.

Lit is built on the Web Components standard. This foundation gives me confidence in its excellent integration capabilities. The Shadow DOM provides crucial CSS style isolation, simplifying testing and offering robust style management. Its built-in lifecycle methods are well-documented, and Lit components reactively re-render upon prop changes. Finally, HTML templating is a core feature, eliminating the need for direct DOM manipulation.

Is Lit Faster?

While performance benchmarks are beyond the scope of this article, Lit's architectural design inherently points to performance advantages. According to its documentation, Lit is a "lightweight" framework. It doesn't rely on a Virtual DOM, instead leveraging native browser standards like Web Components and Shadow DOM. Its re-rendering mechanism is highly optimized, updating only specific, changed fragments of the DOM, which should translate to quicker updates.

What's the Learning Curve for Developers?

Writing components in Lit feels quite similar to React. You'll find familiar concepts like a render method and lifecycle methods. While the documentation differs significantly in how props are passed and the underlying mechanisms, developers experienced with JavaScript or React will likely find the transition to Lit quite intuitive.

How Does the Production Bundle Size Compare?

To provide a tangible comparison, I created a repository featuring a simple button component implemented in both Lit and React, as two separate packages. For bundling, I used Vite with Rollup and the following configuration options:

minify: true
rollupOptions.external: disabled (useful when runtime is loaded via CDN, but disabled for Lit here to include its runtime)
sourcemap: false
build.lib.formats: ["es"]

The React package included:
React + JSX Runtime + Component

The Lit package included:
Lit + runtime Lit + Component

I've included the full runtime for both to ensure a fair comparison, as comparing only the component file itself can be misleading. Lit's rendering relies on decorators, ES classes, and helpers from @lit/reactive-element and lit-html. Thus, a larger component file generated by Lit doesn't necessarily mean a larger overall bundle or slower performance.

According to my comparison, the React bundle size was 20.08KB in its rendered version and 5.84KB when Gzip compressed.
The Lit package size was 18.01KB in its rendered version and 8.03KB when Gzip compressed.

These results show that the Lit bundle is smaller in its raw, rendered version than React's. However, the compressed version is what truly matters for network transfer to the browser. In this specific comparison, React performs better in terms of Gzip compression. This could be due to the Gzip algorithm's effectiveness in finding and replacing repetitive data patterns, which React's compiled output apparently facilitates more efficiently. It's challenging to predict how bundle sizes would compare with highly complex components, extensive state management, or React's advanced optimization features.

Summary

It's important to remember that bundle size isn't the only metric that matters. While Lit's bundle is larger than React's for the compressed version in this specific test, the framework offers significant advantages in other areas:

1. Native Elements: Lit leverages native browser elements, which inherently reduces the amount of abstraction code needed.

2. No Virtual DOM: Lit does not use a Virtual DOM, which generally leads to better memory management and potentially faster updates by directly interacting with the real DOM.

3. Easier Learning Curve (My Opinion): I found Lit to be simpler to learn than React. Adding the package, creating a component, registering it, and displaying it took me just a few minutes the first time. I recall the initial learning curve for React being steeper.

4. Interoperability: This is a major advantage. Using React or Angular components directly within vanilla JavaScript is significantly more challenging. Lit components, as Web Components, are inherently interoperable across different frameworks or even in vanilla JS environments.

My aim here isn't to declare that everyone should now exclusively write code using Lit. Instead, my goal is to present it as a compelling alternative, especially well-suited for smaller projects or scenarios where its unique strengths shine.

In the future, I'd love to conduct a comparison of more advanced components, incorporate optimization mechanisms, and perform more extensive performance tests.
